name: Run Playwright Tests

on:
  pull_request:
  schedule:
    - cron: "15 13 * * *" # Runs daily at 13:15 UTC
  workflow_dispatch:

jobs:
  run-donobu-flows:
    runs-on: ubuntu-latest
    timeout-minutes: 180  # Job ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï (3ÏãúÍ∞Ñ) - workers 1Î°ú Ïù∏Ìï¥ Ïã§Ìñâ ÏãúÍ∞Ñ Ï¶ùÍ∞Ä

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install System dependencies
        run: sudo apt-get update && sudo apt-get install -y --no-install-recommends xvfb jq

      - name: Install Donobu dependencies
        run: npm install && npx playwright install --with-deps

      - name: Verify environment variables
        run: |
          if [ -z "${{ secrets.GOOGLE_GEMINI_API_KEY }}" ]; then
            echo "‚ùå ERROR: GOOGLE_GEMINI_API_KEY secret is not set!"
            exit 1
          else
            echo "‚úÖ GOOGLE_GEMINI_API_KEY is set"
          fi
          if [ -z "${{ vars.EMAIL }}" ]; then
            echo "‚ùå ERROR: EMAIL variable is not set!"
            exit 1
          else
            echo "‚úÖ EMAIL is set"
          fi
          if [ -z "${{ secrets.PASSWORD }}" ]; then
            echo "‚ùå ERROR: PASSWORD secret is not set!"
            exit 1
          else
            echo "‚úÖ PASSWORD is set"
          fi

      - name: Run Playwright tests
        id: run_tests
        continue-on-error: true
        env:
          CI: true
          GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GEMINI_API_KEY }}
          GOOGLE_GENERATIVE_AI_MODEL_NAME: gemini-2.5-flash
          EMAIL: ${{ vars.EMAIL }}
          PASSWORD: ${{ secrets.PASSWORD }}
          # CI ÌôòÍ≤ΩÏóêÏÑúÎäî self-healing ÎπÑÌôúÏÑ±ÌôîÌïòÏó¨ API Ìò∏Ï∂ú ÏµúÏÜåÌôî
          SELF_HEAL_TESTS_ENABLED: false
        run: |
          echo "üöÄ Starting Playwright tests..."
          echo "Workers: 1 (CI mode - to prevent API quota exceeded)"
          echo "Retries: 0 (to avoid additional API calls on failure)"
          echo "SELF_HEAL_TESTS_ENABLED: false (to minimize API calls)"
          echo "Timeout: 180 minutes"
          echo ""
          echo "üìã Running tests with detailed output..."
          echo "Note: Check the logs below for any test failures"
          
          # Ensure test-results directory exists
          mkdir -p test-results
          mkdir -p playwright-report
          
          # Run tests and capture exit code
          echo "Running: xvfb-run npx playwright test --reporter=list"
          echo "Note: JSON and HTML reporters are configured in playwright.config.ts"
          echo "=========================================="
          echo "TEST EXECUTION START"
          echo "=========================================="
          echo "Current directory: $(pwd)"
          echo "Playwright config: $(ls -la playwright.config.ts 2>/dev/null || echo 'NOT FOUND')"
          echo ""
          
          # Run tests (reporter is already configured in playwright.config.ts)
          # Don't override reporter settings to avoid conflicts
          set +e  # Don't exit on error
          xvfb-run npx playwright test --reporter=list 2>&1 | tee test-execution.log
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          echo ""
          echo "=========================================="
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ ALL TESTS PASSED (exit code: $TEST_EXIT_CODE)"
          else
            echo "‚ùå TESTS FAILED (exit code: $TEST_EXIT_CODE)"
          fi
          echo "=========================================="
          echo ""
          
          # Wait a moment for reporters to finish writing files
          sleep 2
          
          # Check what was actually created
          echo "üìÅ Checking what files were created..."
          echo "All files in current directory:"
          ls -la | head -30
          echo ""
          echo "All files in test-results:"
          ls -la test-results/ 2>/dev/null || echo "test-results directory does not exist"
          echo ""
          echo "All JSON files:"
          find . -name "*.json" -type f 2>/dev/null | head -20 || echo "No JSON files found"
          echo ""
          
          # Verify report file was created
          if [ -f "test-results/playwright-report.json" ]; then
            echo "‚úÖ SUCCESS: test-results/playwright-report.json was created"
            echo "File size: $(du -h test-results/playwright-report.json | cut -f1)"
            echo "First few lines of JSON:"
            head -5 test-results/playwright-report.json || echo "Could not read file"
          else
            echo "‚ùå ERROR: test-results/playwright-report.json was NOT created!"
            echo "This might indicate:"
            echo "  1. Tests did not run at all"
            echo "  2. Reporter configuration issue"
            echo "  3. File permission issue"
            echo ""
            echo "Checking Playwright version:"
            npx playwright --version || echo "Could not get version"
            echo ""
            echo "Checking if test-results directory is writable:"
            touch test-results/test-write.txt 2>&1 && rm test-results/test-write.txt && echo "‚úÖ Directory is writable" || echo "‚ùå Directory is NOT writable"
            echo ""
            echo "Attempting to generate JSON report manually..."
            # Try to generate report using Playwright's merge command if available
            if [ -f "test-results/.last-run.json" ]; then
              echo "Found .last-run.json, attempting to use it..."
              cp test-results/.last-run.json test-results/playwright-report.json 2>/dev/null && echo "‚úÖ Copied .last-run.json to playwright-report.json" || echo "‚ùå Could not copy file"
            fi
          fi
          echo ""
          
          echo "üìù Test execution completed with exit code: $TEST_EXIT_CODE"
          echo ""
          
          # Check if report files were generated
          echo "üîç Checking for test result files..."
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la | head -20
          echo ""
          
          if [ -f "test-results/playwright-report.json" ]; then
            echo "‚úÖ JSON report found: test-results/playwright-report.json"
            ls -lh test-results/playwright-report.json
            echo "File size: $(du -h test-results/playwright-report.json | cut -f1)"
          else
            echo "‚ùå JSON report NOT found: test-results/playwright-report.json"
            echo "Checking test-results directory..."
            if [ -d "test-results" ]; then
              echo "test-results directory exists. Contents:"
              ls -la test-results/ || echo "Cannot list test-results directory"
            else
              echo "test-results directory does not exist"
            fi
            echo ""
            echo "Checking for any JSON files in current directory:"
            find . -name "*.json" -type f 2>/dev/null | head -10 || echo "No JSON files found"
          fi
          
          if [ -d "playwright-report" ]; then
            echo "‚úÖ HTML report directory found: playwright-report"
            echo "Contents:"
            ls -la playwright-report/ | head -10
          else
            echo "‚ùå HTML report directory NOT found: playwright-report"
          fi
          
          echo ""
          echo "üìä Summary:"
          echo "- Test exit code: $TEST_EXIT_CODE"
          echo "- Check the test results above for failed/skipped tests"
          echo "- Failed tests will show error details"
          echo "- Skipped tests may be due to dependencies or testIgnore configuration"
          
          # Exit with test exit code but continue-on-error will prevent job failure
          # This allows us to upload artifacts even if tests fail
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è Tests failed but continuing to upload artifacts..."
          fi
          exit 0

      - name: Upload Raw Results
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: test-results
          path: test-results/
          retention-days: 3
          if-no-files-found: warn
      
      - name: Upload Test Execution Log
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: test-execution-log
          path: test-execution.log
          retention-days: 3
          if-no-files-found: ignore

      - name: Upload HTML Report
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: html-report
          path: playwright-report/
          retention-days: 3
          if-no-files-found: warn

      - name: Report test results
        if: always()
        continue-on-error: true
        run: |
          echo "## üìä Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Always try to generate table from execution log
          if [ -f "test-execution.log" ]; then
            echo "### üìä Test Results Table" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| File | Passed | Self-Healed | Failed | Timed Out | Skipped | Interrupted | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|------|--------|-------------|--------|-----------|---------|-------------|----------|" >> $GITHUB_STEP_SUMMARY
            
            # Extract test results - look for test file patterns in log
            # Pattern examples:
            # - [logged-in-tests] ‚Ä∫ tests/logged-in/dashboard/dashboard-values.spec.ts:22:5 ‚Ä∫ dashboard-verify-values
            # - 1 failed
            # - 21 passed (23.3m)
            
            # Create a temporary file to store results
            TEMP_RESULTS=$(mktemp)
            
            # Extract all test file paths and their status
            grep -E "\[.*\] ‚Ä∫ tests/.*\.spec\.ts" test-execution.log | sed -E 's/.*‚Ä∫ tests\/([^:]+\.spec\.ts).*/\1/' | sort -u | while read -r file; do
              # Check if this file has a failed test
              if grep -q "\[.*\] ‚Ä∫ tests/$file.*failed\|\[.*\] ‚Ä∫ tests/$file.*Error\|\[.*\] ‚Ä∫ tests/$file.*Timeout" test-execution.log; then
                echo "$file|0|0 ‚ù§Ô∏è‚Äçü©π|1 ‚ùå|0 ‚è∞|0|0 ‚ö°|-" >> "$TEMP_RESULTS"
              # Check if this file has a skipped test
              elif grep -q "\[.*\] ‚Ä∫ tests/$file.*skipped" test-execution.log; then
                echo "$file|0|0 ‚ù§Ô∏è‚Äçü©π|0|0 ‚è∞|1 ‚è≠Ô∏è|0 ‚ö°|-" >> "$TEMP_RESULTS"
              # Otherwise assume passed
              else
                echo "$file|1 ‚úÖ|0 ‚ù§Ô∏è‚Äçü©π|0|0 ‚è∞|0|0 ‚ö°|-" >> "$TEMP_RESULTS"
              fi
            done
            
            # Add results to summary and count totals from actual table rows
            PASSED_TOTAL=0
            FAILED_TOTAL=0
            SKIPPED_TOTAL=0
            
            if [ -s "$TEMP_RESULTS" ]; then
              while IFS='|' read -r file passed healed failed timeout skipped interrupted duration; do
                echo "| $file | $passed | $healed | $failed | $timeout | $skipped | $interrupted | $duration |" >> $GITHUB_STEP_SUMMARY
                # Count totals from actual table rows (more accurate)
                if echo "$passed" | grep -q "‚úÖ"; then
                  PASSED_TOTAL=$((PASSED_TOTAL + 1))
                fi
                if echo "$failed" | grep -q "‚ùå"; then
                  FAILED_TOTAL=$((FAILED_TOTAL + 1))
                fi
                if echo "$skipped" | grep -q "‚è≠Ô∏è"; then
                  SKIPPED_TOTAL=$((SKIPPED_TOTAL + 1))
                fi
              done < <(sort -u "$TEMP_RESULTS")
            fi
            rm -f "$TEMP_RESULTS"
            
            # Extract duration from the final summary line in log
            FINAL_SUMMARY=$(tail -20 test-execution.log | grep -E "[0-9]+ (passed|failed|skipped|did not run)" | tail -3)
            DURATION=$(echo "$FINAL_SUMMARY" | grep -oE "\([0-9]+\.[0-9]+m\)" | grep -oE "[0-9]+\.[0-9]+" | head -1 || echo "0")
            
            # Use totals from actual table rows (more accurate than parsing log)
            TOTAL=$((PASSED_TOTAL + FAILED_TOTAL + SKIPPED_TOTAL))
            
            echo "| **TOTAL** | **$PASSED_TOTAL ‚úÖ** | **0 ‚ù§Ô∏è‚Äçü©π** | **$FAILED_TOTAL ‚ùå** | **0 ‚è∞** | **$SKIPPED_TOTAL ‚è≠Ô∏è** | **0 ‚ö°** | **${DURATION}m** |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Save totals to file for Slack notification
            echo "PASSED_TOTAL=$PASSED_TOTAL" >> test-totals.env
            echo "FAILED_TOTAL=$FAILED_TOTAL" >> test-totals.env
            echo "SKIPPED_TOTAL=$SKIPPED_TOTAL" >> test-totals.env
            echo "DURATION=$DURATION" >> test-totals.env
          fi
          
          echo "### üîç Test Results Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # If JSON report exists, use it for more detailed analysis
          if [ -f "test-results/playwright-report.json" ]; then
            # Try to generate markdown report, but don't fail if it doesn't work
            MARKDOWN_OUTPUT=$(npm exec playwright-json-to-markdown < "test-results/playwright-report.json" 2>&1)
            if [ $? -eq 0 ] && [ -n "$MARKDOWN_OUTPUT" ]; then
              echo "$MARKDOWN_OUTPUT" >> $GITHUB_STEP_SUMMARY
            else
              # Fallback: Generate detailed summary from JSON
              echo "### üìà Test Results Table" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Generate table from JSON
              echo "| File | Passed | Self-Healed | Failed | Timed Out | Skipped | Interrupted | Duration |" >> $GITHUB_STEP_SUMMARY
              echo "|------|--------|-------------|--------|-----------|---------|-------------|----------|" >> $GITHUB_STEP_SUMMARY
              
              # Extract test results per file
              jq -r '.suites[]? | 
                "| \(.file // "Unknown") | " + 
                (if .specs[]?.tests[0].results[0].status == "passed" then "1 ‚úÖ" else "0" end) + " | " +
                "0 ‚ù§Ô∏è‚Äçü©π | " +
                (if .specs[]?.tests[0].results[0].status == "failed" then "1 ‚ùå" else "0" end) + " | " +
                "0 ‚è∞ | " +
                (if .specs[]?.tests[0].results[0].status == "skipped" then "1 ‚è≠Ô∏è" else "0" end) + " | " +
                "0 ‚ö° | " +
                "\(.specs[0].tests[0].results[0].duration // 0)ms |"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY || echo "| Error parsing JSON | - | - | - | - | - | - | - |" >> $GITHUB_STEP_SUMMARY
              
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Add totals
              TOTAL=$(jq '.stats.total' test-results/playwright-report.json 2>/dev/null || echo "0")
              PASSED=$(jq '.stats.expected' test-results/playwright-report.json 2>/dev/null || echo "0")
              FAILED=$(jq '.stats.unexpected' test-results/playwright-report.json 2>/dev/null || echo "0")
              SKIPPED=$(jq '.stats.skipped' test-results/playwright-report.json 2>/dev/null || echo "0")
              DURATION=$(jq '.stats.duration' test-results/playwright-report.json 2>/dev/null || echo "0")
              DURATION_SEC=$(echo "scale=1; $DURATION / 1000" | bc 2>/dev/null || echo "0")
              
              echo "| **TOTAL** | **$PASSED ‚úÖ** | **0 ‚ù§Ô∏è‚Äçü©π** | **$FAILED ‚ùå** | **0 ‚è∞** | **$SKIPPED ‚è≠Ô∏è** | **0 ‚ö°** | **${DURATION_SEC}s** |" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîç Failed and Skipped Tests Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            # Extract failed and skipped tests with detailed error information
            FAILED_COUNT=$(jq '[.suites[]?.specs[]? | select(.tests[0].results[0].status == "failed")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
            if [ "$FAILED_COUNT" -gt 0 ]; then
              echo "**‚ùå Failed Tests ($FAILED_COUNT):**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              jq -r '.suites[]?.specs[]? | select(.tests[0].results[0].status == "failed") | 
                "#### \(.title)\n" +
                "- **File:** \(.file)\n" +
                "- **Error:** \(.tests[0].results[0].error?.message // "Unknown error")\n" +
                "- **Stack:** \(.tests[0].results[0].error?.stack // "No stack trace")\n"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY
            else
              echo "**‚úÖ Failed Tests:** None" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            SKIPPED_COUNT=$(jq '[.suites[]?.specs[]? | select(.tests[0].results[0].status == "skipped")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
            if [ "$SKIPPED_COUNT" -gt 0 ]; then
              echo "**‚è≠Ô∏è Skipped Tests ($SKIPPED_COUNT):**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              jq -r '.suites[]?.specs[]? | select(.tests[0].results[0].status == "skipped") | 
                "- \(.title) (\(.file))"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY
            else
              echo "**‚è≠Ô∏è Skipped Tests:** None" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è JSON report file (playwright-report.json) not found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** JSON report file is required for detailed test analysis." >> $GITHUB_STEP_SUMMARY
            echo "Check the test results table above (generated from execution log) or the 'Run Playwright tests' step logs for full details." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìÅ File System Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -d "test-results" ]; then
            echo "‚úÖ test-results directory exists" >> $GITHUB_STEP_SUMMARY
            echo "Contents:" >> $GITHUB_STEP_SUMMARY
            ls -la test-results/ | head -20 >> $GITHUB_STEP_SUMMARY || echo "Cannot list directory" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå test-results directory does NOT exist" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -d "playwright-report" ]; then
            echo "‚úÖ playwright-report directory exists" >> $GITHUB_STEP_SUMMARY
            echo "Contents:" >> $GITHUB_STEP_SUMMARY
            ls -la playwright-report/ | head -20 >> $GITHUB_STEP_SUMMARY || echo "Cannot list directory" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå playwright-report directory does NOT exist" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f "test-execution.log" ]; then
            echo "### üìù Test Execution Log Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Last 30 lines of execution log:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            tail -30 test-execution.log >> $GITHUB_STEP_SUMMARY || echo "Could not read log" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Post to Slack
        if: always()
        continue-on-error: true
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_USER_EMAIL: ${{ secrets.SLACK_USER_EMAIL }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          # Use Bot Token for direct message (preferred) or fallback to webhook
          if [ -n "$SLACK_BOT_TOKEN" ] && [ -n "$SLACK_USER_EMAIL" ]; then
            echo "üì® Sending Slack DM using Bot Token..."
            WORKFLOW_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
            WORKFLOW_RUN="${GITHUB_REPOSITORY} - Run #${GITHUB_RUN_NUMBER}"
            
            # Load totals if available
            if [ -f "test-totals.env" ]; then
              source test-totals.env
            else
              PASSED_TOTAL=0
              FAILED_TOTAL=0
              SKIPPED_TOTAL=0
              DURATION=0
            fi
            
            # Determine status emoji
            if [ "$FAILED_TOTAL" -eq 0 ] && [ "$SKIPPED_TOTAL" -eq 0 ]; then
              STATUS_EMOJI="‚úÖ"
              STATUS_TEXT="All tests passed"
            elif [ "$FAILED_TOTAL" -gt 0 ]; then
              STATUS_EMOJI="‚ùå"
              STATUS_TEXT="$FAILED_TOTAL test(s) failed"
            else
              STATUS_EMOJI="‚ö†Ô∏è"
              STATUS_TEXT="$SKIPPED_TOTAL test(s) skipped"
            fi
            
            # Build test results list from execution log
            TEST_LIST_FILE=$(mktemp)
            if [ -f "test-execution.log" ]; then
              # Extract test file results
              TEMP_RESULTS=$(mktemp)
              grep -E "\[.*\] ‚Ä∫ tests/.*\.spec\.ts" test-execution.log | sed -E 's/.*‚Ä∫ tests\/([^:]+\.spec\.ts).*/\1/' | sort -u | while read -r file; do
                if grep -q "\[.*\] ‚Ä∫ tests/$file.*failed\|\[.*\] ‚Ä∫ tests/$file.*Error\|\[.*\] ‚Ä∫ tests/$file.*Timeout" test-execution.log; then
                  echo "$file|‚ùå" >> "$TEMP_RESULTS"
                elif grep -q "\[.*\] ‚Ä∫ tests/$file.*skipped" test-execution.log; then
                  echo "$file|‚è≠Ô∏è" >> "$TEMP_RESULTS"
                else
                  echo "$file|‚úÖ" >> "$TEMP_RESULTS"
                fi
              done
              
              if [ -s "$TEMP_RESULTS" ]; then
                sort -u "$TEMP_RESULTS" | head -20 | while IFS='|' read -r file status; do
                  echo "‚Ä¢ \`$file\` $status" >> "$TEST_LIST_FILE"
                done
              fi
              rm -f "$TEMP_RESULTS"
            fi
            TEST_LIST=$(cat "$TEST_LIST_FILE" 2>/dev/null || echo "")
            rm -f "$TEST_LIST_FILE"
            
            # Create Slack message payload using jq to avoid YAML parsing issues
            SLACK_PAYLOAD_FILE=$(mktemp)
            
            # Build blocks array
            jq -n \
              --arg status_emoji "$STATUS_EMOJI" \
              --arg repo "$GITHUB_REPOSITORY" \
              --arg run_num "$GITHUB_RUN_NUMBER" \
              --arg status_text "$STATUS_TEXT" \
              --arg duration "$DURATION" \
              --arg passed "$PASSED_TOTAL" \
              --arg failed "$FAILED_TOTAL" \
              --arg skipped "$SKIPPED_TOTAL" \
              --arg workflow_url "$WORKFLOW_URL" \
              --arg test_list "$TEST_LIST" \
              '{
                "blocks": [
                  {
                    "type": "header",
                    "text": {
                      "type": "plain_text",
                      "text": ($status_emoji + " Playwright Test Results")
                    }
                  },
                  {
                    "type": "section",
                    "fields": [
                      {
                        "type": "mrkdwn",
                        "text": ("*Repository:*\n" + $repo)
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Run:*\n#" + $run_num)
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Status:*\n" + $status_text)
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Duration:*\n" + $duration + "m")
                      }
                    ]
                  },
                  {
                    "type": "section",
                    "fields": [
                      {
                        "type": "mrkdwn",
                        "text": ("*Passed:*\n" + $passed + " ‚úÖ")
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Failed:*\n" + $failed + " ‚ùå")
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Skipped:*\n" + $skipped + " ‚è≠Ô∏è")
                      }
                    ]
                  }
                ]
              }' > "$SLACK_PAYLOAD_FILE"
            
            # Add test results list if available
            if [ -n "$TEST_LIST" ]; then
              TEST_LIST_ESCAPED=$(echo "$TEST_LIST" | jq -Rs . | sed 's/^"//;s/"$//')
              jq --arg test_list_text "$TEST_LIST" \
                '.blocks += [{
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ("*Test Results:*\n" + $test_list_text)
                  }
                }]' "$SLACK_PAYLOAD_FILE" > "${SLACK_PAYLOAD_FILE}.tmp" && mv "${SLACK_PAYLOAD_FILE}.tmp" "$SLACK_PAYLOAD_FILE"
            fi
            
            # Add view details button
            jq --arg workflow_url "$WORKFLOW_URL" \
              '.blocks += [{
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "View Details"
                    },
                    "url": $workflow_url
                  }
                ]
              }]' "$SLACK_PAYLOAD_FILE" > "${SLACK_PAYLOAD_FILE}.tmp" && mv "${SLACK_PAYLOAD_FILE}.tmp" "$SLACK_PAYLOAD_FILE"
            
            # Get user ID from email
            USER_RESPONSE=$(curl -s -X POST "https://slack.com/api/users.lookupByEmail" \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"email\":\"$SLACK_USER_EMAIL\"}")
            
            USER_ID=$(echo "$USER_RESPONSE" | jq -r '.user.id // empty')
            
            if [ -z "$USER_ID" ] || [ "$USER_ID" = "null" ]; then
              echo "‚ùå Failed to find Slack user with email: $SLACK_USER_EMAIL"
              echo "Response: $USER_RESPONSE"
            else
              echo "‚úÖ Found Slack user ID: $USER_ID"
              
              # Open DM conversation
              DM_RESPONSE=$(curl -s -X POST "https://slack.com/api/conversations.open" \
                -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"users\":\"$USER_ID\"}")
              
              CHANNEL_ID=$(echo "$DM_RESPONSE" | jq -r '.channel.id // empty')
              
              if [ -z "$CHANNEL_ID" ] || [ "$CHANNEL_ID" = "null" ]; then
                echo "‚ùå Failed to open DM conversation"
                echo "Response: $DM_RESPONSE"
              else
                echo "‚úÖ Opened DM channel: $CHANNEL_ID"
                
                # Send message to DM
                SEND_RESPONSE=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
                  -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "{\"channel\":\"$CHANNEL_ID\",\"blocks\":$(cat "$SLACK_PAYLOAD_FILE" | jq '.blocks')}")
                
                if echo "$SEND_RESPONSE" | jq -e '.ok == true' > /dev/null; then
                  echo "‚úÖ Successfully sent Slack DM to $SLACK_USER_EMAIL"
                else
                  echo "‚ùå Failed to send Slack DM"
                  echo "Response: $SEND_RESPONSE"
                fi
              fi
            fi
            
            rm -f "$SLACK_PAYLOAD_FILE"
          elif [ -n "$SLACK_WEBHOOK_URL" ]; then
            # Fallback to webhook if Bot Token is not available
            echo "üì® Sending Slack notification using Webhook (fallback)..."
            
            curl -X POST -H 'Content-type: application/json' \
              --data @"$SLACK_PAYLOAD_FILE" \
              "$SLACK_WEBHOOK_URL" || echo "Failed to send Slack notification"
            
            rm -f "$SLACK_PAYLOAD_FILE"
          else
            echo "‚ö†Ô∏è SLACK_BOT_TOKEN and SLACK_USER_EMAIL (or SLACK_WEBHOOK_URL) not set, skipping Slack notification."
            echo "To enable Slack DM notifications, set the following GitHub Secrets:"
            echo "  - SLACK_BOT_TOKEN: Your Slack Bot Token (xoxb-...)"
            echo "  - SLACK_USER_EMAIL: Your Slack email address"
            echo ""
            echo "Or use webhook:"
            echo "  - SLACK_WEBHOOK_URL: Your Slack Incoming Webhook URL"
          fi

      # Create a self-healing PR only when this workflow was not triggered by a pull-request.
      - name: Automatically create a pull request for fixing failed tests (if any)
        if: ${{ github.event_name != 'pull_request' }}
        continue-on-error: true
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Fix failing Playwright tests"
          title: "[Fixed] Playwright tests"
          body: |
            This PR was automatically created to fix failing Playwright tests.
            
            ## Test Results
            Check the workflow run for detailed test results.
            
            ## Changes
            This PR includes fixes for the failing tests detected in the last run.
          branch: fix-playwright-tests-for-${{ github.ref_name }}
          base: ${{ github.ref_name }}
          delete-branch: true
          # Don't fail if branch already exists
          branch-suffix: timestamp
