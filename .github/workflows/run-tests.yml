name: Run Playwright Tests

on:
  pull_request:
  schedule:
    - cron: "15 13 * * *" # Runs daily at 13:15 UTC
  workflow_dispatch:

jobs:
  run-donobu-flows:
    runs-on: ubuntu-latest
    timeout-minutes: 180 # Job íƒ€ì„ì•„ì›ƒ ì„¤ì • (3ì‹œê°„) - workers 1ë¡œ ì¸í•´ ì‹¤í–‰ ì‹œê°„ ì¦ê°€

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install System dependencies
        run: sudo apt-get update && sudo apt-get install -y --no-install-recommends xvfb jq

      - name: Install Donobu dependencies
        run: npm install && npx playwright install --with-deps

      - name: Verify environment variables
        run: |
          if [ -z "${{ secrets.GOOGLE_GEMINI_API_KEY }}" ]; then
            echo "âŒ ERROR: GOOGLE_GEMINI_API_KEY secret is not set!"
            exit 1
          else
            echo "âœ… GOOGLE_GEMINI_API_KEY is set"
          fi
          if [ -z "${{ vars.EMAIL }}" ]; then
            echo "âŒ ERROR: EMAIL variable is not set!"
            exit 1
          else
            echo "âœ… EMAIL is set"
          fi
          if [ -z "${{ secrets.PASSWORD }}" ]; then
            echo "âŒ ERROR: PASSWORD secret is not set!"
            exit 1
          else
            echo "âœ… PASSWORD is set"
          fi

      - name: Run Playwright tests
        id: run_tests
        continue-on-error: true
        env:
          CI: true
          GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GEMINI_API_KEY }}
          GOOGLE_GENERATIVE_AI_MODEL_NAME: gemini-2.5-flash
          EMAIL: ${{ vars.EMAIL }}
          PASSWORD: ${{ secrets.PASSWORD }}
          # CI í™˜ê²½ì—ì„œëŠ” self-healing ë¹„í™œì„±í™”í•˜ì—¬ API í˜¸ì¶œ ìµœì†Œí™”
          SELF_HEAL_TESTS_ENABLED: false
        run: |
          echo "ğŸš€ Starting Playwright tests..."
          echo "Workers: 1 (CI mode - to prevent API quota exceeded)"
          echo "Retries: 0 (to avoid additional API calls on failure)"
          echo "SELF_HEAL_TESTS_ENABLED: false (to minimize API calls)"
          echo "Timeout: 180 minutes"
          echo ""
          echo "ğŸ“‹ Running tests with detailed output..."
          echo "Note: Check the logs below for any test failures"

          # Ensure test-results directory exists
          mkdir -p test-results
          mkdir -p playwright-report

          # Run tests and capture exit code
          echo "Running: xvfb-run npx playwright test --reporter=list"
          echo "Note: JSON and HTML reporters are configured in playwright.config.ts"
          echo "=========================================="
          echo "TEST EXECUTION START"
          echo "=========================================="
          echo "Current directory: $(pwd)"
          echo "Playwright config: $(ls -la playwright.config.ts 2>/dev/null || echo 'NOT FOUND')"
          echo ""

          # Run tests (reporter is already configured in playwright.config.ts)
          # Don't override reporter settings to avoid conflicts
          set +e  # Don't exit on error
          xvfb-run npx playwright test --reporter=list 2>&1 | tee test-execution.log
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error

          echo ""
          echo "=========================================="
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "âœ… ALL TESTS PASSED (exit code: $TEST_EXIT_CODE)"
          else
            echo "âŒ TESTS FAILED (exit code: $TEST_EXIT_CODE)"
          fi
          echo "=========================================="
          echo ""

          # Wait a moment for reporters to finish writing files
          sleep 2

          # Check what was actually created
          echo "ğŸ“ Checking what files were created..."
          echo "All files in current directory:"
          ls -la | head -30
          echo ""
          echo "All files in test-results:"
          ls -la test-results/ 2>/dev/null || echo "test-results directory does not exist"
          echo ""
          echo "All JSON files:"
          find . -name "*.json" -type f 2>/dev/null | head -20 || echo "No JSON files found"
          echo ""

          # Verify report file was created
          if [ -f "test-results/playwright-report.json" ]; then
            echo "âœ… SUCCESS: test-results/playwright-report.json was created"
            echo "File size: $(du -h test-results/playwright-report.json | cut -f1)"
            echo "First few lines of JSON:"
            head -5 test-results/playwright-report.json || echo "Could not read file"
          else
            echo "âŒ ERROR: test-results/playwright-report.json was NOT created!"
            echo "This might indicate:"
            echo "  1. Tests did not run at all"
            echo "  2. Reporter configuration issue"
            echo "  3. File permission issue"
            echo ""
            echo "Checking Playwright version:"
            npx playwright --version || echo "Could not get version"
            echo ""
            echo "Checking if test-results directory is writable:"
            touch test-results/test-write.txt 2>&1 && rm test-results/test-write.txt && echo "âœ… Directory is writable" || echo "âŒ Directory is NOT writable"
            echo ""
            echo "Attempting to generate JSON report manually..."
            # Try to generate report using Playwright's merge command if available
            if [ -f "test-results/.last-run.json" ]; then
              echo "Found .last-run.json, attempting to use it..."
              cp test-results/.last-run.json test-results/playwright-report.json 2>/dev/null && echo "âœ… Copied .last-run.json to playwright-report.json" || echo "âŒ Could not copy file"
            fi
          fi
          echo ""

          echo "ğŸ“ Test execution completed with exit code: $TEST_EXIT_CODE"
          echo ""

          # Check if report files were generated
          echo "ğŸ” Checking for test result files..."
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la | head -20
          echo ""

          if [ -f "test-results/playwright-report.json" ]; then
            echo "âœ… JSON report found: test-results/playwright-report.json"
            ls -lh test-results/playwright-report.json
            echo "File size: $(du -h test-results/playwright-report.json | cut -f1)"
          else
            echo "âŒ JSON report NOT found: test-results/playwright-report.json"
            echo "Checking test-results directory..."
            if [ -d "test-results" ]; then
              echo "test-results directory exists. Contents:"
              ls -la test-results/ || echo "Cannot list test-results directory"
            else
              echo "test-results directory does not exist"
            fi
            echo ""
            echo "Checking for any JSON files in current directory:"
            find . -name "*.json" -type f 2>/dev/null | head -10 || echo "No JSON files found"
          fi

          if [ -d "playwright-report" ]; then
            echo "âœ… HTML report directory found: playwright-report"
            echo "Contents:"
            ls -la playwright-report/ | head -10
          else
            echo "âŒ HTML report directory NOT found: playwright-report"
          fi

          echo ""
          echo "ğŸ“Š Summary:"
          echo "- Test exit code: $TEST_EXIT_CODE"
          echo "- Check the test results above for failed/skipped tests"
          echo "- Failed tests will show error details"
          echo "- Skipped tests may be due to dependencies or testIgnore configuration"

          # Exit with test exit code but continue-on-error will prevent job failure
          # This allows us to upload artifacts even if tests fail
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "âš ï¸ Tests failed but continuing to upload artifacts..."
          fi
          exit 0

      - name: Upload Raw Results
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: test-results
          path: test-results/
          retention-days: 3
          if-no-files-found: warn

      - name: Upload Test Execution Log
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: test-execution-log
          path: test-execution.log
          retention-days: 3
          if-no-files-found: ignore

      - name: Upload HTML Report
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: html-report
          path: playwright-report/
          retention-days: 3
          if-no-files-found: warn

      - name: Report test results
        if: always()
        continue-on-error: true
        run: |
          echo "## ğŸ“Š Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Always try to generate table from execution log
          if [ -f "test-execution.log" ]; then
            echo "### ğŸ“Š Test Results Table" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| File | Passed | Self-Healed | Failed | Timed Out | Skipped | Interrupted | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|------|--------|-------------|--------|-----------|---------|-------------|----------|" >> $GITHUB_STEP_SUMMARY
            
            # Extract test results - look for test file patterns in log
            # Pattern examples:
            # - [logged-in-tests] â€º tests/logged-in/dashboard/dashboard-values.spec.ts:22:5 â€º dashboard-verify-values
            # - 1 failed
            # - 21 passed (23.3m)
            
            # Create a temporary file to store results
            TEMP_RESULTS=$(mktemp)
            
            # Extract all test file paths and their status
            grep -E "\[.*\] â€º tests/.*\.spec\.ts" test-execution.log | sed -E 's/.*â€º tests\/([^:]+\.spec\.ts).*/\1/' | sort -u | while read -r file; do
              # Check if this file has a failed test
              if grep -q "\[.*\] â€º tests/$file.*failed\|\[.*\] â€º tests/$file.*Error\|\[.*\] â€º tests/$file.*Timeout" test-execution.log; then
                echo "$file|0|0 â¤ï¸â€ğŸ©¹|1 âŒ|0 â°|0|0 âš¡|-" >> "$TEMP_RESULTS"
              # Check if this file has a skipped test
              elif grep -q "\[.*\] â€º tests/$file.*skipped" test-execution.log; then
                echo "$file|0|0 â¤ï¸â€ğŸ©¹|0|0 â°|1 â­ï¸|0 âš¡|-" >> "$TEMP_RESULTS"
              # Otherwise assume passed
              else
                echo "$file|1 âœ…|0 â¤ï¸â€ğŸ©¹|0|0 â°|0|0 âš¡|-" >> "$TEMP_RESULTS"
              fi
            done
            
            # Add results to summary and count totals from actual table rows
            PASSED_TOTAL=0
            FAILED_TOTAL=0
            SKIPPED_TOTAL=0
            
            if [ -s "$TEMP_RESULTS" ]; then
              while IFS='|' read -r file passed healed failed timeout skipped interrupted duration; do
                echo "| $file | $passed | $healed | $failed | $timeout | $skipped | $interrupted | $duration |" >> $GITHUB_STEP_SUMMARY
                # Count totals from actual table rows (more accurate)
                if echo "$passed" | grep -q "âœ…"; then
                  PASSED_TOTAL=$((PASSED_TOTAL + 1))
                fi
                if echo "$failed" | grep -q "âŒ"; then
                  FAILED_TOTAL=$((FAILED_TOTAL + 1))
                fi
                if echo "$skipped" | grep -q "â­ï¸"; then
                  SKIPPED_TOTAL=$((SKIPPED_TOTAL + 1))
                fi
              done < <(sort -u "$TEMP_RESULTS")
            fi
            rm -f "$TEMP_RESULTS"
            
            # Extract duration from the final summary line in log
            FINAL_SUMMARY=$(tail -20 test-execution.log | grep -E "[0-9]+ (passed|failed|skipped|did not run)" | tail -3)
            DURATION=$(echo "$FINAL_SUMMARY" | grep -oE "\([0-9]+\.[0-9]+m\)" | grep -oE "[0-9]+\.[0-9]+" | head -1 || echo "0")
            
            # Use totals from actual table rows (more accurate than parsing log)
            TOTAL=$((PASSED_TOTAL + FAILED_TOTAL + SKIPPED_TOTAL))
            
            echo "| **TOTAL** | **$PASSED_TOTAL âœ…** | **0 â¤ï¸â€ğŸ©¹** | **$FAILED_TOTAL âŒ** | **0 â°** | **$SKIPPED_TOTAL â­ï¸** | **0 âš¡** | **${DURATION}m** |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Save totals to file for Slack notification
            echo "PASSED_TOTAL=$PASSED_TOTAL" >> test-totals.env
            echo "FAILED_TOTAL=$FAILED_TOTAL" >> test-totals.env
            echo "SKIPPED_TOTAL=$SKIPPED_TOTAL" >> test-totals.env
            echo "DURATION=$DURATION" >> test-totals.env
          fi

          echo "### ğŸ” Test Results Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # If JSON report exists, use it for more detailed analysis
          if [ -f "test-results/playwright-report.json" ]; then
            # Try to generate markdown report, but don't fail if it doesn't work
            MARKDOWN_OUTPUT=$(npm exec playwright-json-to-markdown < "test-results/playwright-report.json" 2>&1)
            if [ $? -eq 0 ] && [ -n "$MARKDOWN_OUTPUT" ]; then
              echo "$MARKDOWN_OUTPUT" >> $GITHUB_STEP_SUMMARY
            else
              # Fallback: Generate detailed summary from JSON
              echo "### ğŸ“ˆ Test Results Table" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Generate table from JSON
              echo "| File | Passed | Self-Healed | Failed | Timed Out | Skipped | Interrupted | Duration |" >> $GITHUB_STEP_SUMMARY
              echo "|------|--------|-------------|--------|-----------|---------|-------------|----------|" >> $GITHUB_STEP_SUMMARY
              
              # Extract test results per file
              jq -r '.suites[]? | 
                "| \(.file // "Unknown") | " + 
                (if .specs[]?.tests[0].results[0].status == "passed" then "1 âœ…" else "0" end) + " | " +
                "0 â¤ï¸â€ğŸ©¹ | " +
                (if .specs[]?.tests[0].results[0].status == "failed" then "1 âŒ" else "0" end) + " | " +
                "0 â° | " +
                (if .specs[]?.tests[0].results[0].status == "skipped" then "1 â­ï¸" else "0" end) + " | " +
                "0 âš¡ | " +
                "\(.specs[0].tests[0].results[0].duration // 0)ms |"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY || echo "| Error parsing JSON | - | - | - | - | - | - | - |" >> $GITHUB_STEP_SUMMARY
              
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Add totals
              TOTAL=$(jq '.stats.total' test-results/playwright-report.json 2>/dev/null || echo "0")
              PASSED=$(jq '.stats.expected' test-results/playwright-report.json 2>/dev/null || echo "0")
              FAILED=$(jq '.stats.unexpected' test-results/playwright-report.json 2>/dev/null || echo "0")
              SKIPPED=$(jq '.stats.skipped' test-results/playwright-report.json 2>/dev/null || echo "0")
              DURATION=$(jq '.stats.duration' test-results/playwright-report.json 2>/dev/null || echo "0")
              DURATION_SEC=$(echo "scale=1; $DURATION / 1000" | bc 2>/dev/null || echo "0")
              
              echo "| **TOTAL** | **$PASSED âœ…** | **0 â¤ï¸â€ğŸ©¹** | **$FAILED âŒ** | **0 â°** | **$SKIPPED â­ï¸** | **0 âš¡** | **${DURATION_SEC}s** |" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ğŸ” Failed and Skipped Tests Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            # Extract failed and skipped tests with detailed error information
            FAILED_COUNT=$(jq '[.suites[]?.specs[]? | select(.tests[0].results[0].status == "failed")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
            if [ "$FAILED_COUNT" -gt 0 ]; then
              echo "**âŒ Failed Tests ($FAILED_COUNT):**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              jq -r '.suites[]?.specs[]? | select(.tests[0].results[0].status == "failed") | 
                "#### \(.title)\n" +
                "- **File:** \(.file)\n" +
                "- **Error:** \(.tests[0].results[0].error?.message // "Unknown error")\n" +
                "- **Stack:** \(.tests[0].results[0].error?.stack // "No stack trace")\n"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY
            else
              echo "**âœ… Failed Tests:** None" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            SKIPPED_COUNT=$(jq '[.suites[]?.specs[]? | select(.tests[0].results[0].status == "skipped")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
            if [ "$SKIPPED_COUNT" -gt 0 ]; then
              echo "**â­ï¸ Skipped Tests ($SKIPPED_COUNT):**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              jq -r '.suites[]?.specs[]? | select(.tests[0].results[0].status == "skipped") | 
                "- \(.title) (\(.file))"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY
            else
              echo "**â­ï¸ Skipped Tests:** None" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ JSON report file (playwright-report.json) not found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** JSON report file is required for detailed test analysis." >> $GITHUB_STEP_SUMMARY
            echo "Check the test results table above (generated from execution log) or the 'Run Playwright tests' step logs for full details." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“ File System Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -d "test-results" ]; then
            echo "âœ… test-results directory exists" >> $GITHUB_STEP_SUMMARY
            echo "Contents:" >> $GITHUB_STEP_SUMMARY
            ls -la test-results/ | head -20 >> $GITHUB_STEP_SUMMARY || echo "Cannot list directory" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ test-results directory does NOT exist" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -d "playwright-report" ]; then
            echo "âœ… playwright-report directory exists" >> $GITHUB_STEP_SUMMARY
            echo "Contents:" >> $GITHUB_STEP_SUMMARY
            ls -la playwright-report/ | head -20 >> $GITHUB_STEP_SUMMARY || echo "Cannot list directory" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ playwright-report directory does NOT exist" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "test-execution.log" ]; then
            echo "### ğŸ“ Test Execution Log Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Last 30 lines of execution log:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            tail -30 test-execution.log >> $GITHUB_STEP_SUMMARY || echo "Could not read log" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Post to Slack
        if: always()
        continue-on-error: true
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_USER_EMAIL: ${{ secrets.SLACK_USER_EMAIL || vars.slack_user_email || vars.SLACK_USER_EMAIL }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          echo "=========================================="
          echo "ğŸ“¨ Slack Notification Setup"
          echo "=========================================="
          echo "Checking environment variables..."
          
          if [ -z "$SLACK_BOT_TOKEN" ]; then
            echo "âŒ SLACK_BOT_TOKEN is not set"
          else
            echo "âœ… SLACK_BOT_TOKEN is set (length: ${#SLACK_BOT_TOKEN} chars)"
            echo "   Token starts with: ${SLACK_BOT_TOKEN:0:10}..."
          fi
          
          if [ -z "$SLACK_USER_EMAIL" ]; then
            echo "âŒ SLACK_USER_EMAIL is not set"
          else
            echo "âœ… SLACK_USER_EMAIL is set: $SLACK_USER_EMAIL"
          fi
          
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "âš ï¸ SLACK_WEBHOOK_URL is not set (will not use webhook fallback)"
          else
            echo "âœ… SLACK_WEBHOOK_URL is set"
          fi
          
          echo ""
          
          # Use Bot Token for direct message (preferred) or fallback to webhook
          if [ -n "$SLACK_BOT_TOKEN" ] && [ -n "$SLACK_USER_EMAIL" ]; then
            echo "ğŸ“¨ Sending Slack DM using Bot Token..."
            WORKFLOW_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
            WORKFLOW_RUN="${GITHUB_REPOSITORY} - Run #${GITHUB_RUN_NUMBER}"
            
            # Load totals if available
            if [ -f "test-totals.env" ]; then
              source test-totals.env
            else
              PASSED_TOTAL=0
              FAILED_TOTAL=0
              SKIPPED_TOTAL=0
              DURATION=0
            fi
            
            # Determine status emoji
            if [ "$FAILED_TOTAL" -eq 0 ] && [ "$SKIPPED_TOTAL" -eq 0 ]; then
              STATUS_EMOJI="âœ…"
              STATUS_TEXT="All tests passed"
            elif [ "$FAILED_TOTAL" -gt 0 ]; then
              STATUS_EMOJI="âŒ"
              STATUS_TEXT="$FAILED_TOTAL test(s) failed"
            else
              STATUS_EMOJI="âš ï¸"
              STATUS_TEXT="$SKIPPED_TOTAL test(s) skipped"
            fi
            
            # Build test results list from execution log
            TEST_LIST_FILE=$(mktemp)
            if [ -f "test-execution.log" ]; then
              # Extract test file results
              TEMP_RESULTS=$(mktemp)
              grep -E "\[.*\] â€º tests/.*\.spec\.ts" test-execution.log | sed -E 's/.*â€º tests\/([^:]+\.spec\.ts).*/\1/' | sort -u | while read -r file; do
                if grep -q "\[.*\] â€º tests/$file.*failed\|\[.*\] â€º tests/$file.*Error\|\[.*\] â€º tests/$file.*Timeout" test-execution.log; then
                  echo "$file|âŒ" >> "$TEMP_RESULTS"
                elif grep -q "\[.*\] â€º tests/$file.*skipped" test-execution.log; then
                  echo "$file|â­ï¸" >> "$TEMP_RESULTS"
                else
                  echo "$file|âœ…" >> "$TEMP_RESULTS"
                fi
              done
              
              if [ -s "$TEMP_RESULTS" ]; then
                sort -u "$TEMP_RESULTS" | head -20 | while IFS='|' read -r file status; do
                  echo "â€¢ \`$file\` $status" >> "$TEST_LIST_FILE"
                done
              fi
              rm -f "$TEMP_RESULTS"
            fi
            TEST_LIST=$(cat "$TEST_LIST_FILE" 2>/dev/null || echo "")
            rm -f "$TEST_LIST_FILE"
            
            # Create Slack message payload using jq to avoid YAML parsing issues
            SLACK_PAYLOAD_FILE=$(mktemp)
            
            # Build blocks array
            jq -n \
              --arg status_emoji "$STATUS_EMOJI" \
              --arg repo "$GITHUB_REPOSITORY" \
              --arg run_num "$GITHUB_RUN_NUMBER" \
              --arg status_text "$STATUS_TEXT" \
              --arg duration "$DURATION" \
              --arg passed "$PASSED_TOTAL" \
              --arg failed "$FAILED_TOTAL" \
              --arg skipped "$SKIPPED_TOTAL" \
              --arg workflow_url "$WORKFLOW_URL" \
              --arg test_list "$TEST_LIST" \
              '{
                "blocks": [
                  {
                    "type": "header",
                    "text": {
                      "type": "plain_text",
                      "text": ($status_emoji + " Playwright Test Results")
                    }
                  },
                  {
                    "type": "section",
                    "fields": [
                      {
                        "type": "mrkdwn",
                        "text": ("*Repository:*\n" + $repo)
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Run:*\n#" + $run_num)
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Status:*\n" + $status_text)
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Duration:*\n" + $duration + "m")
                      }
                    ]
                  },
                  {
                    "type": "section",
                    "fields": [
                      {
                        "type": "mrkdwn",
                        "text": ("*Passed:*\n" + $passed + " âœ…")
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Failed:*\n" + $failed + " âŒ")
                      },
                      {
                        "type": "mrkdwn",
                        "text": ("*Skipped:*\n" + $skipped + " â­ï¸")
                      }
                    ]
                  }
                ]
              }' > "$SLACK_PAYLOAD_FILE"
            
            # Add test results list if available
            if [ -n "$TEST_LIST" ]; then
              TEST_LIST_ESCAPED=$(echo "$TEST_LIST" | jq -Rs . | sed 's/^"//;s/"$//')
              jq --arg test_list_text "$TEST_LIST" \
                '.blocks += [{
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ("*Test Results:*\n" + $test_list_text)
                  }
                }]' "$SLACK_PAYLOAD_FILE" > "${SLACK_PAYLOAD_FILE}.tmp" && mv "${SLACK_PAYLOAD_FILE}.tmp" "$SLACK_PAYLOAD_FILE"
            fi
            
            # Add view details button
            jq --arg workflow_url "$WORKFLOW_URL" \
              '.blocks += [{
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "View Details"
                    },
                    "url": $workflow_url
                  }
                ]
              }]' "$SLACK_PAYLOAD_FILE" > "${SLACK_PAYLOAD_FILE}.tmp" && mv "${SLACK_PAYLOAD_FILE}.tmp" "$SLACK_PAYLOAD_FILE"
            
            # Get user ID from email
            echo "ğŸ” Looking up Slack user by email: $SLACK_USER_EMAIL"
            USER_RESPONSE=$(curl -s -X POST "https://slack.com/api/users.lookupByEmail" \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"email\":\"$SLACK_USER_EMAIL\"}")
            
            USER_OK=$(echo "$USER_RESPONSE" | jq -r '.ok // false')
            USER_ID=$(echo "$USER_RESPONSE" | jq -r '.user.id // empty')
            USER_ERROR=$(echo "$USER_RESPONSE" | jq -r '.error // empty')
            
            if [ "$USER_OK" != "true" ] || [ -z "$USER_ID" ] || [ "$USER_ID" = "null" ]; then
              echo "âŒ Failed to find Slack user with email: $SLACK_USER_EMAIL"
              echo "Error: $USER_ERROR"
              echo "Full response: $USER_RESPONSE"
              echo ""
              echo "ğŸ’¡ í™•ì¸ ì‚¬í•­:"
              echo "1. ì´ë©”ì¼ ì£¼ì†Œê°€ ì •í™•í•œì§€ í™•ì¸í•˜ì„¸ìš”: $SLACK_USER_EMAIL"
              echo "2. í•´ë‹¹ ì´ë©”ì¼ë¡œ Slack ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì— ê°€ì…ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”"
            else
              echo "âœ… Found Slack user ID: $USER_ID"
              
              # Open DM conversation (or use existing channel)
              echo "ğŸ”“ Opening DM conversation..."
              DM_RESPONSE=$(curl -s -X POST "https://slack.com/api/conversations.open" \
                -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"users\":\"$USER_ID\"}")
              
              DM_OK=$(echo "$DM_RESPONSE" | jq -r '.ok // false')
              CHANNEL_ID=$(echo "$DM_RESPONSE" | jq -r '.channel.id // empty')
              DM_ERROR=$(echo "$DM_RESPONSE" | jq -r '.error // empty')
              DM_WARNING=$(echo "$DM_RESPONSE" | jq -r '.warning // empty')
              
              if [ "$DM_OK" != "true" ] || [ -z "$CHANNEL_ID" ] || [ "$CHANNEL_ID" = "null" ]; then
                echo "âŒ Failed to open DM conversation"
                echo "Error: $DM_ERROR"
                if [ -n "$DM_WARNING" ]; then
                  echo "Warning: $DM_WARNING"
                fi
                echo "Full response: $DM_RESPONSE"
                echo ""
                echo "ğŸ’¡ í•´ê²° ë°©ë²• (ì¤‘ìš”!):"
                echo "1. Slack ì•±ì„ ì—´ê³  'GitHub Actions Bot-Ray'ë¥¼ ê²€ìƒ‰í•˜ì„¸ìš”"
                echo "2. Botì„ í´ë¦­í•˜ì—¬ DMì„ ì—´ê³  ì•„ë¬´ ë©”ì‹œì§€ë‚˜ ë³´ë‚´ì„¸ìš” (ì˜ˆ: 'ì•ˆë…•í•˜ì„¸ìš”' ë˜ëŠ” 'í…ŒìŠ¤íŠ¸')"
                echo "3. ì´ë ‡ê²Œ í•˜ë©´ Botì´ ì‚¬ìš©ìì—ê²Œ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤"
                echo ""
                echo "âš ï¸ Slackì—ì„œëŠ” Botì´ ì‚¬ìš©ìì—ê²Œ DMì„ ë³´ë‚´ë ¤ë©´ ì‚¬ìš©ìê°€ Botì—ê²Œ ë¨¼ì € ë©”ì‹œì§€ë¥¼ ë³´ë‚´ì•¼ í•©ë‹ˆë‹¤."
              else
                echo "âœ… Opened DM channel: $CHANNEL_ID"
                
                # Send message to DM
                echo "ğŸ“¤ Sending message to DM..."
                SEND_RESPONSE=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
                  -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "{\"channel\":\"$CHANNEL_ID\",\"blocks\":$(cat "$SLACK_PAYLOAD_FILE" | jq '.blocks')}")
                
                SEND_OK=$(echo "$SEND_RESPONSE" | jq -r '.ok // false')
                SEND_ERROR=$(echo "$SEND_RESPONSE" | jq -r '.error // empty')
                
                if [ "$SEND_OK" = "true" ]; then
                  echo "âœ… Successfully sent Slack DM to $SLACK_USER_EMAIL"
                else
                  echo "âŒ Failed to send Slack DM"
                  echo "Error: $SEND_ERROR"
                  echo "Full response: $SEND_RESPONSE"
                  echo ""
                  echo "ğŸ’¡ í•´ê²° ë°©ë²•:"
                  echo "1. Slackì—ì„œ 'GitHub Actions Bot-Ray'ì—ê²Œ ë¨¼ì € ë©”ì‹œì§€ë¥¼ ë³´ë‚´ì£¼ì„¸ìš”"
                  echo "2. Slack App ì„¤ì •ì—ì„œ ë‹¤ìŒ ê¶Œí•œì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”:"
                  echo "   - chat:write"
                  echo "   - im:write"
                  echo "   - users:read.email"
                  echo "3. ê¶Œí•œì„ ì¶”ê°€í–ˆë‹¤ë©´ 'Reinstall to Workspace'ë¥¼ í´ë¦­í•˜ì„¸ìš”"
                fi
              fi
            fi
            
            rm -f "$SLACK_PAYLOAD_FILE"
            echo ""
            echo "=========================================="
            echo "âœ… Slack notification step completed"
            echo "=========================================="
          elif [ -n "$SLACK_WEBHOOK_URL" ]; then
            # Fallback to webhook if Bot Token is not available
            echo "ğŸ“¨ Sending Slack notification using Webhook (fallback)..."
            
            curl -X POST -H 'Content-type: application/json' \
              --data @"$SLACK_PAYLOAD_FILE" \
              "$SLACK_WEBHOOK_URL" || echo "Failed to send Slack notification"
            
            rm -f "$SLACK_PAYLOAD_FILE"
          else
            echo ""
            echo "=========================================="
            echo "âš ï¸ Slack Notification Skipped"
            echo "=========================================="
            echo "SLACK_BOT_TOKEN and SLACK_USER_EMAIL (or SLACK_WEBHOOK_URL) not set"
            echo ""
            echo "To enable Slack DM notifications, set the following GitHub Secrets:"
            echo "  - SLACK_BOT_TOKEN: Your Slack Bot Token (xoxb-...)"
            echo "  - SLACK_USER_EMAIL: Your Slack email address"
            echo ""
            echo "Or use webhook:"
            echo "  - SLACK_WEBHOOK_URL: Your Slack Incoming Webhook URL"
            echo ""
            echo "=========================================="
          fi

      # Create a self-healing PR only when this workflow was not triggered by a pull-request.
      - name: Automatically create a pull request for fixing failed tests (if any)
        if: ${{ github.event_name != 'pull_request' }}
        continue-on-error: true
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Fix failing Playwright tests"
          title: "[Fixed] Playwright tests"
          body: |
            This PR was automatically created to fix failing Playwright tests.

            ## Test Results
            Check the workflow run for detailed test results.

            ## Changes
            This PR includes fixes for the failing tests detected in the last run.
          branch: fix-playwright-tests-for-${{ github.ref_name }}
          base: ${{ github.ref_name }}
          delete-branch: true
          # Don't fail if branch already exists
          branch-suffix: timestamp
