name: Run Playwright Tests

on:
  pull_request:
  schedule:
    - cron: "15 13 * * *" # Runs daily at 13:15 UTC
  workflow_dispatch:

jobs:
  run-donobu-flows:
    runs-on: ubuntu-latest
    timeout-minutes: 180 # Job íƒ€ì„ì•„ì›ƒ ì„¤ì • (3ì‹œê°„) - workers 1ë¡œ ì¸í•´ ì‹¤í–‰ ì‹œê°„ ì¦ê°€

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install System dependencies
        run: sudo apt-get update && sudo apt-get install -y --no-install-recommends xvfb jq

      - name: Install Donobu dependencies
        run: npm install && npx playwright install --with-deps

      - name: Verify environment variables
        run: |
          if [ -z "${{ secrets.GOOGLE_GEMINI_API_KEY }}" ]; then
            echo "âŒ ERROR: GOOGLE_GEMINI_API_KEY secret is not set!"
            exit 1
          else
            echo "âœ… GOOGLE_GEMINI_API_KEY is set"
          fi
          if [ -z "${{ vars.EMAIL }}" ]; then
            echo "âŒ ERROR: EMAIL variable is not set!"
            exit 1
          else
            echo "âœ… EMAIL is set"
          fi
          if [ -z "${{ secrets.PASSWORD }}" ]; then
            echo "âŒ ERROR: PASSWORD secret is not set!"
            exit 1
          else
            echo "âœ… PASSWORD is set"
          fi
          if [ -z "${{ vars.D2C_EMAIL }}" ]; then
            echo "âš ï¸ WARNING: D2C_EMAIL variable is not set!"
            echo "D2C login tests will be skipped"
          else
            echo "âœ… D2C_EMAIL is set"
          fi
          if [ -z "${{ secrets.D2C_PASSWORD }}" ]; then
            echo "âš ï¸ WARNING: D2C_PASSWORD secret is not set!"
            echo "D2C login tests will be skipped"
          else
            echo "âœ… D2C_PASSWORD is set"
          fi

      - name: Run Playwright tests
        id: run_tests
        continue-on-error: true
        env:
          CI: true
          GOOGLE_GENERATIVE_AI_API_KEY: ${{ secrets.GOOGLE_GEMINI_API_KEY }}
          GOOGLE_GENERATIVE_AI_MODEL_NAME: gemini-2.5-flash
          EMAIL: ${{ vars.EMAIL }}
          PASSWORD: ${{ secrets.PASSWORD }}
          D2C_EMAIL: ${{ vars.D2C_EMAIL || '' }}
          D2C_PASSWORD: ${{ secrets.D2C_PASSWORD || '' }}
          # CI í™˜ê²½ì—ì„œëŠ” self-healing ë¹„í™œì„±í™”í•˜ì—¬ API í˜¸ì¶œ ìµœì†Œí™”
          SELF_HEAL_TESTS_ENABLED: false
        run: |
          echo "ğŸš€ Starting Playwright tests..."
          echo "Workers: 1 (CI mode - to prevent API quota exceeded)"
          echo "Retries: 0 (to avoid additional API calls on failure)"
          echo "SELF_HEAL_TESTS_ENABLED: false (to minimize API calls)"
          echo "Timeout: 180 minutes"
          echo ""
          echo "ğŸ“‹ Running tests with detailed output..."
          echo "Note: Check the logs below for any test failures"

          # Ensure test-results directory exists
          mkdir -p test-results
          mkdir -p playwright-report

          # Run tests and capture exit code
          echo "Running: xvfb-run npx playwright test --reporter=list"
          echo "Note: JSON and HTML reporters are configured in playwright.config.ts"
          echo "=========================================="
          echo "TEST EXECUTION START"
          echo "=========================================="
          echo "Current directory: $(pwd)"
          echo "Playwright config: $(ls -la playwright.config.ts 2>/dev/null || echo 'NOT FOUND')"
          echo ""

          # Run tests (reporter is already configured in playwright.config.ts)
          # Don't override reporter settings to avoid conflicts
          set +e  # Don't exit on error
          echo "Checking Playwright installation..."
          npx playwright --version || echo "Playwright not found"
          echo ""
          echo "Listing available tests..."
          npx playwright test --list 2>&1 | head -30 || echo "Failed to list tests"
          echo ""
          echo "Running tests..."
          # Run tests and capture output
          xvfb-run npx playwright test --reporter=list --reporter=json --reporter=html 2>&1 | tee test-execution.log
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Wait for reporters to finish
          sleep 3
          
          # Check if JSON report was created, if not try to generate it
          if [ ! -f "test-results/playwright-report.json" ]; then
            echo "âš ï¸  JSON report not found, checking for alternative report files..."
            # Try to find any JSON report files
            if [ -f "test-results/.last-run.json" ]; then
              echo "Found .last-run.json, but this is not a full report"
            fi
            # Try to use Playwright's merge command if available
            if command -v npx >/dev/null 2>&1; then
              echo "Attempting to generate JSON report from test results..."
              npx playwright merge-reports test-results/.last-run.json --output test-results/playwright-report.json 2>&1 || echo "Could not merge reports"
            fi
          fi

          echo ""
          echo "=========================================="
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "âœ… ALL TESTS PASSED (exit code: $TEST_EXIT_CODE)"
          else
            echo "âŒ TESTS FAILED (exit code: $TEST_EXIT_CODE)"
          fi
          echo "=========================================="
          echo ""
          # Analyze test results to show skipped tests
          echo "ğŸ“Š Analyzing test results..."
          echo ""
          echo "=== EXECUTION SUMMARY FROM LOG ==="
          # Extract summary from test execution log
          if [ -f "test-execution.log" ]; then
            echo "Test execution summary:"
            grep -E "(passed|failed|skipped|did not run|Running.*tests)" test-execution.log | tail -10 || echo "Could not extract summary from log"
            echo ""
            # Count tests by status from log
            PASSED_COUNT=$(grep -c "âœ…\|passed" test-execution.log 2>/dev/null || echo "0")
            FAILED_COUNT=$(grep -c "âœ˜\|failed" test-execution.log 2>/dev/null || echo "0")
            SKIPPED_COUNT=$(grep -c "â­ï¸\|skipped\|did not run" test-execution.log 2>/dev/null || echo "0")
            echo "From log analysis:"
            echo "  Passed: $PASSED_COUNT"
            echo "  Failed: $FAILED_COUNT"
            echo "  Skipped/Did not run: $SKIPPED_COUNT"
            echo ""
          fi
          
          if [ -f "test-results/playwright-report.json" ]; then
            echo ""
            echo "=== TEST SUMMARY ==="
            # Try different JSON structures
            if jq -e '.stats' test-results/playwright-report.json >/dev/null 2>&1; then
              # Standard Playwright JSON format
              TOTAL=$(jq '.stats.total' test-results/playwright-report.json 2>/dev/null || echo "0")
              PASSED=$(jq '.stats.expected' test-results/playwright-report.json 2>/dev/null || echo "0")
              FAILED=$(jq '.stats.unexpected' test-results/playwright-report.json 2>/dev/null || echo "0")
              SKIPPED=$(jq '.stats.skipped' test-results/playwright-report.json 2>/dev/null || echo "0")
            elif jq -e '.suites' test-results/playwright-report.json >/dev/null 2>&1; then
              # Alternative format
              TOTAL=$(jq '[.suites[].specs[]?.tests[]?] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
              PASSED=$(jq '[.suites[].specs[]?.tests[]? | select(.results[0].status == "passed")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
              FAILED=$(jq '[.suites[].specs[]?.tests[]? | select(.results[0].status == "failed")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
              SKIPPED=$(jq '[.suites[].specs[]?.tests[]? | select(.results[0].status == "skipped")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
            else
              # Try to extract from test execution log
              TOTAL=$(grep -c "Running.*tests" test-execution.log 2>/dev/null || echo "0")
              PASSED=$(grep -c "âœ…\|passed" test-execution.log 2>/dev/null || echo "0")
              FAILED=$(grep -c "âŒ\|failed" test-execution.log 2>/dev/null || echo "0")
              SKIPPED=$(grep -c "â­ï¸\|skipped" test-execution.log 2>/dev/null || echo "0")
            fi
            echo "Total tests: $TOTAL"
            echo "âœ… Passed: $PASSED"
            echo "âŒ Failed: $FAILED"
            echo "â­ï¸  Skipped: $SKIPPED"
            echo ""
            if [ "$SKIPPED" != "0" ] && [ "$SKIPPED" != "" ] && [ "$SKIPPED" != "null" ]; then
              echo "=== SKIPPED TESTS (likely due to failed dependencies) ==="
              # Try to extract skipped tests from JSON
              if jq -e '.suites' test-results/playwright-report.json >/dev/null 2>&1; then
                jq -r '.suites[].specs[]?.tests[]? | select(.results[0].status == "skipped") | "  - \(.title) [\(.file)]"' test-results/playwright-report.json 2>/dev/null | head -30 || echo "Could not parse skipped tests from JSON"
              else
                echo "  Check test-execution.log above for skipped tests"
                grep -i "skipped\|skip" test-execution.log 2>/dev/null | head -20 || echo "No skipped test info found in log"
              fi
              echo ""
              echo "ğŸ’¡ Tip: Skipped tests are usually due to failed dependencies (e.g., login tests)"
              echo "   Check the failed login tests above to understand why dependent tests were skipped"
              echo "   Common causes:"
              echo "   - dashboard-login failed â†’ logged-in-tests skipped"
              echo "   - d2c-login failed â†’ d2c-logged-in-tests skipped"
              echo "   - b2b-smoke-test-login failed â†’ logged-in-smoke-tests skipped"
            fi
            if [ "$FAILED" != "0" ] && [ "$FAILED" != "" ] && [ "$FAILED" != "null" ]; then
              echo "=== FAILED TESTS ==="
              if jq -e '.suites' test-results/playwright-report.json >/dev/null 2>&1; then
                jq -r '.suites[].specs[]?.tests[]? | select(.results[0].status == "failed") | "  - \(.title) [\(.file)]"' test-results/playwright-report.json 2>/dev/null | head -30 || echo "Could not parse failed tests from JSON"
              else
                echo "  Check test-execution.log above for failed tests"
                grep -i "failed\|âœ˜" test-execution.log 2>/dev/null | head -20 || echo "No failed test info found in log"
              fi
              echo ""
            fi
            else
              echo "âš ï¸  Could not analyze test results: test-results/playwright-report.json not found"
              echo ""
              echo "=== DETAILED ANALYSIS FROM TEST EXECUTION LOG ==="
              if [ -f "test-execution.log" ]; then
                echo ""
                echo "--- Tests that DID run ---"
                grep -E "^\s+[0-9]+\)|passed|failed" test-execution.log | head -30 || echo "No test execution details found"
                echo ""
                echo "--- Tests that DID NOT run (skipped due to dependencies) ---"
                # List all 24 tests and check which ones are missing from execution log
                echo "Expected 24 tests, but only a few ran."
                echo "This usually means:"
                echo "  1. Login tests failed â†’ dependent tests were skipped"
                echo "  2. Check failed login tests above to see why dependencies failed"
                echo ""
                echo "Common dependency chain:"
                echo "  - dashboard-login fails â†’ logged-in-tests skipped (10 tests)"
                echo "  - dashboard-login-rw fails â†’ learner-onboarding-workflow skipped (1 test)"
                echo "  - d2c-login fails â†’ d2c-logged-in-tests skipped (2 tests)"
                echo "  - b2b-smoke-test-login fails â†’ logged-in-smoke-tests skipped (5 tests)"
                echo ""
                echo "To see which specific tests were skipped, check the test list above"
                echo "and compare with the tests that actually ran."
              fi
            fi
          echo ""

          # Wait a moment for reporters to finish writing files
          sleep 2

          # Check what was actually created
          echo "ğŸ“ Checking what files were created..."
          echo "All files in current directory:"
          ls -la | head -30
          echo ""
          echo "All files in test-results:"
          ls -la test-results/ 2>/dev/null || echo "test-results directory does not exist"
          echo ""
          echo "All JSON files:"
          find . -name "*.json" -type f 2>/dev/null | head -20 || echo "No JSON files found"
          echo ""

          # Verify report file was created
          if [ -f "test-results/playwright-report.json" ]; then
            echo "âœ… SUCCESS: test-results/playwright-report.json was created"
            echo "File size: $(du -h test-results/playwright-report.json | cut -f1)"
            echo "First few lines of JSON:"
            head -5 test-results/playwright-report.json || echo "Could not read file"
          else
            echo "âŒ ERROR: test-results/playwright-report.json was NOT created!"
            echo "This might indicate:"
            echo "  1. Tests did not run at all"
            echo "  2. Reporter configuration issue"
            echo "  3. File permission issue"
            echo ""
            echo "Checking Playwright version:"
            npx playwright --version || echo "Could not get version"
            echo ""
            echo "Checking if test-results directory is writable:"
            touch test-results/test-write.txt 2>&1 && rm test-results/test-write.txt && echo "âœ… Directory is writable" || echo "âŒ Directory is NOT writable"
            echo ""
            echo "Attempting to generate JSON report manually..."
            # Try to generate report using Playwright's merge command if available
            if [ -f "test-results/.last-run.json" ]; then
              echo "Found .last-run.json, attempting to use it..."
              cp test-results/.last-run.json test-results/playwright-report.json 2>/dev/null && echo "âœ… Copied .last-run.json to playwright-report.json" || echo "âŒ Could not copy file"
            fi
          fi
          echo ""

          echo "ğŸ“ Test execution completed with exit code: $TEST_EXIT_CODE"
          echo ""

          # Check if report files were generated
          echo "ğŸ” Checking for test result files..."
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la | head -20
          echo ""

          if [ -f "test-results/playwright-report.json" ]; then
            echo "âœ… JSON report found: test-results/playwright-report.json"
            ls -lh test-results/playwright-report.json
            echo "File size: $(du -h test-results/playwright-report.json | cut -f1)"
          else
            echo "âŒ JSON report NOT found: test-results/playwright-report.json"
            echo "Checking test-results directory..."
            if [ -d "test-results" ]; then
              echo "test-results directory exists. Contents:"
              ls -la test-results/ || echo "Cannot list test-results directory"
            else
              echo "test-results directory does not exist"
            fi
            echo ""
            echo "Checking for any JSON files in current directory:"
            find . -name "*.json" -type f 2>/dev/null | head -10 || echo "No JSON files found"
          fi

          if [ -d "playwright-report" ]; then
            echo "âœ… HTML report directory found: playwright-report"
            echo "Contents:"
            ls -la playwright-report/ | head -10
          else
            echo "âŒ HTML report directory NOT found: playwright-report"
          fi

          echo ""
          echo "ğŸ“Š Summary:"
          echo "- Test exit code: $TEST_EXIT_CODE"
          echo "- Check the test results above for failed/skipped tests"
          echo "- Failed tests will show error details"
          echo "- Skipped tests may be due to dependencies or testIgnore configuration"

          # Check if tests actually ran
          if [ ! -f "test-execution.log" ] || [ ! -s "test-execution.log" ]; then
            echo "âŒ ERROR: Test execution log is empty or missing!"
            echo "Tests may not have run at all."
            exit 1
          fi

          # Check if any tests were executed
          if ! grep -q "Running\|passed\|failed\|skipped" test-execution.log; then
            echo "âŒ ERROR: No test execution found in log!"
            echo "Test execution may have failed before tests could run."
            echo "Last 50 lines of log:"
            tail -50 test-execution.log
            exit 1
          fi

          # Exit with test exit code but continue-on-error will prevent job failure
          # This allows us to upload artifacts even if tests fail
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "âš ï¸ Tests failed but continuing to upload artifacts..."
          fi

          # Don't exit 0 - let the actual exit code propagate
          exit $TEST_EXIT_CODE

      - name: Upload Raw Results
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: test-results
          path: test-results/
          retention-days: 3
          if-no-files-found: warn

      - name: Upload Test Execution Log
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: test-execution-log
          path: test-execution.log
          retention-days: 3
          if-no-files-found: ignore

      - name: Upload HTML Report
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: html-report
          path: playwright-report/
          retention-days: 3
          if-no-files-found: warn

      - name: Report test results
        if: always()
        continue-on-error: true
        run: |
          echo "## ğŸ“Š Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Always try to generate table from execution log
          if [ -f "test-execution.log" ]; then
            echo "### ğŸ“Š Test Results Table" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| File | Passed | Self-Healed | Failed | Timed Out | Skipped | Interrupted | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|------|--------|-------------|--------|-----------|---------|-------------|----------|" >> $GITHUB_STEP_SUMMARY
            
            # Extract test results - look for test file patterns in log
            # Pattern examples:
            # - [logged-in-tests] â€º tests/logged-in/dashboard/dashboard-values.spec.ts:22:5 â€º dashboard-verify-values
            # - 1 failed
            # - 21 passed (23.3m)
            
            # Create a temporary file to store results
            TEMP_RESULTS=$(mktemp)
            
            # Extract all test file paths and their status
            grep -E "\[.*\] â€º tests/.*\.spec\.ts" test-execution.log | sed -E 's/.*â€º tests\/([^:]+\.spec\.ts).*/\1/' | sort -u | while read -r file; do
              # Check if this file has a failed test
              if grep -q "\[.*\] â€º tests/$file.*failed\|\[.*\] â€º tests/$file.*Error\|\[.*\] â€º tests/$file.*Timeout" test-execution.log; then
                echo "$file|0|0 â¤ï¸â€ğŸ©¹|1 âŒ|0 â°|0|0 âš¡|-" >> "$TEMP_RESULTS"
              # Check if this file has a skipped test
              elif grep -q "\[.*\] â€º tests/$file.*skipped" test-execution.log; then
                echo "$file|0|0 â¤ï¸â€ğŸ©¹|0|0 â°|1 â­ï¸|0 âš¡|-" >> "$TEMP_RESULTS"
              # Otherwise assume passed
              else
                echo "$file|1 âœ…|0 â¤ï¸â€ğŸ©¹|0|0 â°|0|0 âš¡|-" >> "$TEMP_RESULTS"
              fi
            done
            
            # Add results to summary and count totals from actual table rows
            PASSED_TOTAL=0
            FAILED_TOTAL=0
            SKIPPED_TOTAL=0
            
            if [ -s "$TEMP_RESULTS" ]; then
              while IFS='|' read -r file passed healed failed timeout skipped interrupted duration; do
                echo "| $file | $passed | $healed | $failed | $timeout | $skipped | $interrupted | $duration |" >> $GITHUB_STEP_SUMMARY
                # Count totals from actual table rows (more accurate)
                if echo "$passed" | grep -q "âœ…"; then
                  PASSED_TOTAL=$((PASSED_TOTAL + 1))
                fi
                if echo "$failed" | grep -q "âŒ"; then
                  FAILED_TOTAL=$((FAILED_TOTAL + 1))
                fi
                if echo "$skipped" | grep -q "â­ï¸"; then
                  SKIPPED_TOTAL=$((SKIPPED_TOTAL + 1))
                fi
              done < <(sort -u "$TEMP_RESULTS")
            fi
            rm -f "$TEMP_RESULTS"
            
            # Extract duration from the final summary line in log
            FINAL_SUMMARY=$(tail -20 test-execution.log | grep -E "[0-9]+ (passed|failed|skipped|did not run)" | tail -3)
            DURATION=$(echo "$FINAL_SUMMARY" | grep -oE "\([0-9]+\.[0-9]+m\)" | grep -oE "[0-9]+\.[0-9]+" | head -1 || echo "0")
            
            # Use totals from actual table rows (more accurate than parsing log)
            TOTAL=$((PASSED_TOTAL + FAILED_TOTAL + SKIPPED_TOTAL))
            
            echo "| **TOTAL** | **$PASSED_TOTAL âœ…** | **0 â¤ï¸â€ğŸ©¹** | **$FAILED_TOTAL âŒ** | **0 â°** | **$SKIPPED_TOTAL â­ï¸** | **0 âš¡** | **${DURATION}m** |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Save totals to file for Slack notification
            echo "PASSED_TOTAL=$PASSED_TOTAL" >> test-totals.env
            echo "FAILED_TOTAL=$FAILED_TOTAL" >> test-totals.env
            echo "SKIPPED_TOTAL=$SKIPPED_TOTAL" >> test-totals.env
            echo "DURATION=$DURATION" >> test-totals.env
          fi

          echo "### ğŸ” Test Results Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # If JSON report exists, use it for more detailed analysis
          if [ -f "test-results/playwright-report.json" ]; then
            # Try to generate markdown report, but don't fail if it doesn't work
            MARKDOWN_OUTPUT=$(npm exec playwright-json-to-markdown < "test-results/playwright-report.json" 2>&1)
            if [ $? -eq 0 ] && [ -n "$MARKDOWN_OUTPUT" ]; then
              echo "$MARKDOWN_OUTPUT" >> $GITHUB_STEP_SUMMARY
            else
              # Fallback: Generate detailed summary from JSON
              echo "### ğŸ“ˆ Test Results Table" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Generate table from JSON
              echo "| File | Passed | Self-Healed | Failed | Timed Out | Skipped | Interrupted | Duration |" >> $GITHUB_STEP_SUMMARY
              echo "|------|--------|-------------|--------|-----------|---------|-------------|----------|" >> $GITHUB_STEP_SUMMARY
              
              # Extract test results per file
              jq -r '.suites[]? | 
                "| \(.file // "Unknown") | " + 
                (if .specs[]?.tests[0].results[0].status == "passed" then "1 âœ…" else "0" end) + " | " +
                "0 â¤ï¸â€ğŸ©¹ | " +
                (if .specs[]?.tests[0].results[0].status == "failed" then "1 âŒ" else "0" end) + " | " +
                "0 â° | " +
                (if .specs[]?.tests[0].results[0].status == "skipped" then "1 â­ï¸" else "0" end) + " | " +
                "0 âš¡ | " +
                "\(.specs[0].tests[0].results[0].duration // 0)ms |"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY || echo "| Error parsing JSON | - | - | - | - | - | - | - |" >> $GITHUB_STEP_SUMMARY
              
              echo "" >> $GITHUB_STEP_SUMMARY
              
              # Add totals
              TOTAL=$(jq '.stats.total' test-results/playwright-report.json 2>/dev/null || echo "0")
              PASSED=$(jq '.stats.expected' test-results/playwright-report.json 2>/dev/null || echo "0")
              FAILED=$(jq '.stats.unexpected' test-results/playwright-report.json 2>/dev/null || echo "0")
              SKIPPED=$(jq '.stats.skipped' test-results/playwright-report.json 2>/dev/null || echo "0")
              DURATION=$(jq '.stats.duration' test-results/playwright-report.json 2>/dev/null || echo "0")
              DURATION_SEC=$(echo "scale=1; $DURATION / 1000" | bc 2>/dev/null || echo "0")
              
              echo "| **TOTAL** | **$PASSED âœ…** | **0 â¤ï¸â€ğŸ©¹** | **$FAILED âŒ** | **0 â°** | **$SKIPPED â­ï¸** | **0 âš¡** | **${DURATION_SEC}s** |" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ğŸ” Failed and Skipped Tests Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            # Extract failed and skipped tests with detailed error information
            FAILED_COUNT=$(jq '[.suites[]?.specs[]? | select(.tests[0].results[0].status == "failed")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
            if [ "$FAILED_COUNT" -gt 0 ]; then
              echo "**âŒ Failed Tests ($FAILED_COUNT):**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              jq -r '.suites[]?.specs[]? | select(.tests[0].results[0].status == "failed") | 
                "#### \(.title)\n" +
                "- **File:** \(.file)\n" +
                "- **Error:** \(.tests[0].results[0].error?.message // "Unknown error")\n" +
                "- **Stack:** \(.tests[0].results[0].error?.stack // "No stack trace")\n"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY
            else
              echo "**âœ… Failed Tests:** None" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            SKIPPED_COUNT=$(jq '[.suites[]?.specs[]? | select(.tests[0].results[0].status == "skipped")] | length' test-results/playwright-report.json 2>/dev/null || echo "0")
            if [ "$SKIPPED_COUNT" -gt 0 ]; then
              echo "**â­ï¸ Skipped Tests ($SKIPPED_COUNT):**" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              jq -r '.suites[]?.specs[]? | select(.tests[0].results[0].status == "skipped") | 
                "- \(.title) (\(.file))"' \
                test-results/playwright-report.json 2>/dev/null >> $GITHUB_STEP_SUMMARY
            else
              echo "**â­ï¸ Skipped Tests:** None" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ JSON report file (playwright-report.json) not found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** JSON report file is required for detailed test analysis." >> $GITHUB_STEP_SUMMARY
            echo "Check the test results table above (generated from execution log) or the 'Run Playwright tests' step logs for full details." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“ File System Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -d "test-results" ]; then
            echo "âœ… test-results directory exists" >> $GITHUB_STEP_SUMMARY
            echo "Contents:" >> $GITHUB_STEP_SUMMARY
            ls -la test-results/ | head -20 >> $GITHUB_STEP_SUMMARY || echo "Cannot list directory" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ test-results directory does NOT exist" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -d "playwright-report" ]; then
            echo "âœ… playwright-report directory exists" >> $GITHUB_STEP_SUMMARY
            echo "Contents:" >> $GITHUB_STEP_SUMMARY
            ls -la playwright-report/ | head -20 >> $GITHUB_STEP_SUMMARY || echo "Cannot list directory" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ playwright-report directory does NOT exist" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f "test-execution.log" ]; then
            echo "### ğŸ“ Test Execution Log Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Last 30 lines of execution log:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            tail -30 test-execution.log >> $GITHUB_STEP_SUMMARY || echo "Could not read log" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Post to Slack
        if: always()
        continue-on-error: true
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_USER_EMAIL: ${{ secrets.SLACK_USER_EMAIL || vars.slack_user_email || vars.SLACK_USER_EMAIL }}
          SLACK_USER_ID: ${{ secrets.SLACK_USER_ID || vars.slack_user_id || vars.SLACK_USER_ID }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          echo "=========================================="
          echo "ğŸ“¨ Slack Notification Setup"
          echo "=========================================="
          echo "Checking environment variables..."

          if [ -z "$SLACK_BOT_TOKEN" ]; then
            echo "âŒ SLACK_BOT_TOKEN is not set"
          else
            echo "âœ… SLACK_BOT_TOKEN is set (length: ${#SLACK_BOT_TOKEN} chars)"
            echo "   Token starts with: ${SLACK_BOT_TOKEN:0:10}..."
          fi

          if [ -z "$SLACK_USER_EMAIL" ]; then
            echo "âŒ SLACK_USER_EMAIL is not set"
          else
            echo "âœ… SLACK_USER_EMAIL is set: $SLACK_USER_EMAIL"
          fi

          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "âš ï¸ SLACK_WEBHOOK_URL is not set (will not use webhook fallback)"
          else
            echo "âœ… SLACK_WEBHOOK_URL is set"
          fi

          echo ""

          # Prepare common variables for both Bot Token and Webhook methods
          WORKFLOW_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          WORKFLOW_RUN="${GITHUB_REPOSITORY} - Run #${GITHUB_RUN_NUMBER}"

          # Load totals if available
          if [ -f "test-totals.env" ]; then
            source test-totals.env
          else
            PASSED_TOTAL=0
            FAILED_TOTAL=0
            SKIPPED_TOTAL=0
            DURATION=0
          fi

          # Determine status emoji
          if [ "$FAILED_TOTAL" -eq 0 ] && [ "$SKIPPED_TOTAL" -eq 0 ]; then
            STATUS_EMOJI="âœ…"
            STATUS_TEXT="All tests passed"
          elif [ "$FAILED_TOTAL" -gt 0 ]; then
            STATUS_EMOJI="âŒ"
            STATUS_TEXT="$FAILED_TOTAL test(s) failed"
          else
            STATUS_EMOJI="âš ï¸"
            STATUS_TEXT="$SKIPPED_TOTAL test(s) skipped"
          fi

          # Build test results list from execution log
          TEST_LIST_FILE=$(mktemp)
          if [ -f "test-execution.log" ]; then
            # Extract test file results
            TEMP_RESULTS=$(mktemp)
            grep -E "\[.*\] â€º tests/.*\.spec\.ts" test-execution.log | sed -E 's/.*â€º tests\/([^:]+\.spec\.ts).*/\1/' | sort -u | while read -r file; do
              if grep -q "\[.*\] â€º tests/$file.*failed\|\[.*\] â€º tests/$file.*Error\|\[.*\] â€º tests/$file.*Timeout" test-execution.log; then
                echo "$file|âŒ" >> "$TEMP_RESULTS"
              elif grep -q "\[.*\] â€º tests/$file.*skipped" test-execution.log; then
                echo "$file|â­ï¸" >> "$TEMP_RESULTS"
              else
                echo "$file|âœ…" >> "$TEMP_RESULTS"
              fi
            done
            
            if [ -s "$TEMP_RESULTS" ]; then
              sort -u "$TEMP_RESULTS" | head -20 | while IFS='|' read -r file status; do
                echo "â€¢ \`$file\` $status" >> "$TEST_LIST_FILE"
              done
            fi
            rm -f "$TEMP_RESULTS"
          fi
          TEST_LIST=$(cat "$TEST_LIST_FILE" 2>/dev/null || echo "")
          rm -f "$TEST_LIST_FILE"

          # Create Slack message payload using jq
          SLACK_PAYLOAD_FILE=$(mktemp)

          # Build blocks array
          jq -n \
            --arg status_emoji "$STATUS_EMOJI" \
            --arg repo "$GITHUB_REPOSITORY" \
            --arg run_num "$GITHUB_RUN_NUMBER" \
            --arg status_text "$STATUS_TEXT" \
            --arg duration "$DURATION" \
            --arg passed "$PASSED_TOTAL" \
            --arg failed "$FAILED_TOTAL" \
            --arg skipped "$SKIPPED_TOTAL" \
            --arg workflow_url "$WORKFLOW_URL" \
            --arg test_list "$TEST_LIST" \
            '{
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": ($status_emoji + " Playwright Test Results")
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": ("*Repository:*\n" + $repo)
                    },
                    {
                      "type": "mrkdwn",
                      "text": ("*Run:*\n#" + $run_num)
                    },
                    {
                      "type": "mrkdwn",
                      "text": ("*Status:*\n" + $status_text)
                    },
                    {
                      "type": "mrkdwn",
                      "text": ("*Duration:*\n" + $duration + "m")
                    }
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": ("*Passed:*\n" + $passed + " âœ…")
                    },
                    {
                      "type": "mrkdwn",
                      "text": ("*Failed:*\n" + $failed + " âŒ")
                    },
                    {
                      "type": "mrkdwn",
                      "text": ("*Skipped:*\n" + $skipped + " â­ï¸")
                    }
                  ]
                }
              ]
            }' > "$SLACK_PAYLOAD_FILE"

          # Add test results list if available
          if [ -n "$TEST_LIST" ]; then
            TEST_LIST_ESCAPED=$(echo "$TEST_LIST" | jq -Rs . | sed 's/^"//;s/"$//')
            jq --arg test_list_text "$TEST_LIST" \
              '.blocks += [{
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": ("*Test Results:*\n" + $test_list_text)
                }
              }]' "$SLACK_PAYLOAD_FILE" > "${SLACK_PAYLOAD_FILE}.tmp" && mv "${SLACK_PAYLOAD_FILE}.tmp" "$SLACK_PAYLOAD_FILE"
          fi

          # Add view details button
          jq --arg workflow_url "$WORKFLOW_URL" \
            '.blocks += [{
              "type": "actions",
              "elements": [
                {
                  "type": "button",
                  "text": {
                    "type": "plain_text",
                    "text": "View Details"
                  },
                  "url": $workflow_url
                }
              ]
            }]' "$SLACK_PAYLOAD_FILE" > "${SLACK_PAYLOAD_FILE}.tmp" && mv "${SLACK_PAYLOAD_FILE}.tmp" "$SLACK_PAYLOAD_FILE"

          # Use Bot Token for direct message (preferred) or fallback to webhook
          if [ -n "$SLACK_BOT_TOKEN" ] && ([ -n "$SLACK_USER_ID" ] || [ -n "$SLACK_USER_EMAIL" ]); then
            echo "ğŸ“¨ Sending Slack DM using Bot Token..."
            
            # First, verify the Bot Token works by checking auth.test
            echo "ğŸ” Verifying Bot Token..."
            AUTH_RESPONSE=$(curl -s -X POST "https://slack.com/api/auth.test" \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H "Content-Type: application/json")
            
            AUTH_OK=$(echo "$AUTH_RESPONSE" | jq -r '.ok // false')
            if [ "$AUTH_OK" != "true" ]; then
              AUTH_ERROR=$(echo "$AUTH_RESPONSE" | jq -r '.error // unknown')
              echo "âŒ Bot Token verification failed: $AUTH_ERROR"
              echo "Full response: $AUTH_RESPONSE"
              echo ""
              echo "ğŸ’¡ í™•ì¸ ì‚¬í•­:"
              echo "1. SLACK_BOT_TOKENì´ ì˜¬ë°”ë¥¸ì§€ í™•ì¸í•˜ì„¸ìš”"
              echo "2. Botì´ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì— ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”"
            else
              BOT_USER_ID=$(echo "$AUTH_RESPONSE" | jq -r '.user_id // empty')
              echo "âœ… Bot Token verified (Bot User ID: $BOT_USER_ID)"
              
              # Get user ID from email
              echo "ğŸ” Looking up Slack user by email: $SLACK_USER_EMAIL"
              
              # Try users.lookupByEmail first
              EMAIL_PAYLOAD=$(jq -n --arg email "$SLACK_USER_EMAIL" '{email: $email}')
              echo "ğŸ“¤ Request payload: $EMAIL_PAYLOAD"
              
              USER_RESPONSE=$(curl -s -X POST "https://slack.com/api/users.lookupByEmail" \
                -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                -H "Content-Type: application/json; charset=utf-8" \
                -d "$EMAIL_PAYLOAD")
              
              USER_OK=$(echo "$USER_RESPONSE" | jq -r '.ok // false')
              USER_ID=$(echo "$USER_RESPONSE" | jq -r '.user.id // empty')
              USER_ERROR=$(echo "$USER_RESPONSE" | jq -r '.error // empty')
              
              # If lookupByEmail fails, try users.list as fallback
              if [ "$USER_OK" != "true" ] || [ -z "$USER_ID" ] || [ "$USER_ID" = "null" ]; then
                echo "âš ï¸ users.lookupByEmail failed: $USER_ERROR"
                echo "Trying alternative method: users.list..."
                
                # Get all users and find by email
                USERS_LIST_RESPONSE=$(curl -s -X GET "https://slack.com/api/users.list" \
                  -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                  -H "Content-Type: application/json")
                
                USERS_LIST_OK=$(echo "$USERS_LIST_RESPONSE" | jq -r '.ok // false')
                if [ "$USERS_LIST_OK" = "true" ]; then
                  USER_ID=$(echo "$USERS_LIST_RESPONSE" | jq -r ".members[] | select(.profile.email == \"$SLACK_USER_EMAIL\") | .id" | head -1)
                  
                  if [ -n "$USER_ID" ] && [ "$USER_ID" != "null" ]; then
                    echo "âœ… Found user via users.list: $USER_ID"
                    USER_OK="true"
                  else
                    echo "âŒ User not found in users.list"
                  fi
                else
                  LIST_ERROR=$(echo "$USERS_LIST_RESPONSE" | jq -r '.error // unknown')
                  echo "âŒ users.list also failed: $LIST_ERROR"
                fi
              fi
              
              if [ "$USER_OK" != "true" ] || [ -z "$USER_ID" ] || [ "$USER_ID" = "null" ]; then
                echo "âŒ Failed to find Slack user with email: $SLACK_USER_EMAIL"
                echo "Error: $USER_ERROR"
                echo "Full response: $USER_RESPONSE"
                echo ""
                echo "ğŸ’¡ í™•ì¸ ì‚¬í•­:"
                echo "1. ì´ë©”ì¼ ì£¼ì†Œê°€ ì •í™•í•œì§€ í™•ì¸í•˜ì„¸ìš”: $SLACK_USER_EMAIL"
                echo "2. í•´ë‹¹ ì´ë©”ì¼ë¡œ Slack ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì— ê°€ì…ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”"
                echo "3. Botì— 'users:read.email' ë° 'users:read' ê¶Œí•œì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”"
                echo "4. Slack App ì„¤ì •ì—ì„œ 'OAuth & Permissions' â†’ 'Bot Token Scopes' í™•ì¸"
                echo ""
                echo "ğŸ’¡ ëŒ€ì•ˆ: SLACK_USER_IDë¥¼ ì§ì ‘ ì„¤ì •í•˜ì„¸ìš”"
                echo "   Slackì—ì„œ ì‚¬ìš©ì í”„ë¡œí•„ì„ ì—´ê³  URLì—ì„œ ì‚¬ìš©ì IDë¥¼ ë³µì‚¬í•˜ì„¸ìš”"
                echo "   ì˜ˆ: https://workspace.slack.com/team/U1234567890 â†’ U1234567890"
              fi
            fi
            
            # If we have a valid user ID, proceed with sending DM
            if [ "$USER_OK" = "true" ] && [ -n "$USER_ID" ] && [ "$USER_ID" != "null" ]; then
              echo "âœ… Using Slack user ID: $USER_ID"
              
              # Open DM conversation (or use existing channel)
              echo "ğŸ”“ Opening DM conversation..."
              
              # Create JSON payload using jq
              DM_PAYLOAD=$(jq -n --arg user_id "$USER_ID" '{users: $user_id}')
              
              DM_RESPONSE=$(curl -s -X POST "https://slack.com/api/conversations.open" \
                -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                -H "Content-Type: application/json; charset=utf-8" \
                -d "$DM_PAYLOAD")
              
              DM_OK=$(echo "$DM_RESPONSE" | jq -r '.ok // false')
              CHANNEL_ID=$(echo "$DM_RESPONSE" | jq -r '.channel.id // empty')
              DM_ERROR=$(echo "$DM_RESPONSE" | jq -r '.error // empty')
              DM_WARNING=$(echo "$DM_RESPONSE" | jq -r '.warning // empty')
              
              if [ "$DM_OK" != "true" ] || [ -z "$CHANNEL_ID" ] || [ "$CHANNEL_ID" = "null" ]; then
                echo "âŒ Failed to open DM conversation"
                echo "Error: $DM_ERROR"
                if [ -n "$DM_WARNING" ]; then
                  echo "Warning: $DM_WARNING"
                fi
                echo "Full response: $DM_RESPONSE"
                echo ""
                echo "ğŸ’¡ í•´ê²° ë°©ë²• (ì¤‘ìš”!):"
                echo "1. Slack ì•±ì„ ì—´ê³  'GitHub Actions Bot-Ray'ë¥¼ ê²€ìƒ‰í•˜ì„¸ìš”"
                echo "2. Botì„ í´ë¦­í•˜ì—¬ DMì„ ì—´ê³  ì•„ë¬´ ë©”ì‹œì§€ë‚˜ ë³´ë‚´ì„¸ìš” (ì˜ˆ: 'ì•ˆë…•í•˜ì„¸ìš”' ë˜ëŠ” 'í…ŒìŠ¤íŠ¸')"
                echo "3. ì´ë ‡ê²Œ í•˜ë©´ Botì´ ì‚¬ìš©ìì—ê²Œ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤"
                echo ""
                echo "âš ï¸ Slackì—ì„œëŠ” Botì´ ì‚¬ìš©ìì—ê²Œ DMì„ ë³´ë‚´ë ¤ë©´ ì‚¬ìš©ìê°€ Botì—ê²Œ ë¨¼ì € ë©”ì‹œì§€ë¥¼ ë³´ë‚´ì•¼ í•©ë‹ˆë‹¤."
              else
                echo "âœ… Opened DM channel: $CHANNEL_ID"
                
                # Send message to DM
                echo "ğŸ“¤ Sending message to DM..."
                SEND_RESPONSE=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
                  -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "{\"channel\":\"$CHANNEL_ID\",\"blocks\":$(cat "$SLACK_PAYLOAD_FILE" | jq '.blocks')}")
                
                SEND_OK=$(echo "$SEND_RESPONSE" | jq -r '.ok // false')
                SEND_ERROR=$(echo "$SEND_RESPONSE" | jq -r '.error // empty')
                
                if [ "$SEND_OK" = "true" ]; then
                  echo "âœ… Successfully sent Slack DM to $SLACK_USER_EMAIL"
                else
                  echo "âŒ Failed to send Slack DM"
                  echo "Error: $SEND_ERROR"
                  echo "Full response: $SEND_RESPONSE"
                  echo ""
                  echo "ğŸ’¡ í•´ê²° ë°©ë²•:"
                  echo "1. Slackì—ì„œ 'GitHub Actions Bot-Ray'ì—ê²Œ ë¨¼ì € ë©”ì‹œì§€ë¥¼ ë³´ë‚´ì£¼ì„¸ìš”"
                  echo "2. Slack App ì„¤ì •ì—ì„œ ë‹¤ìŒ ê¶Œí•œì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”:"
                  echo "   - chat:write"
                  echo "   - im:write"
                  echo "   - users:read.email"
                  echo "3. ê¶Œí•œì„ ì¶”ê°€í–ˆë‹¤ë©´ 'Reinstall to Workspace'ë¥¼ í´ë¦­í•˜ì„¸ìš”"
                fi
              fi
            fi
            
            rm -f "$SLACK_PAYLOAD_FILE"
            echo ""
            echo "=========================================="
            echo "âœ… Slack notification step completed"
            echo "=========================================="
          elif [ -n "$SLACK_WEBHOOK_URL" ]; then
            # Fallback to webhook if Bot Token is not available
            echo "ğŸ“¨ Sending Slack notification using Webhook..."
            echo "âœ… Webhook URL is configured"
            
            WEBHOOK_RESPONSE=$(curl -s -X POST -H 'Content-type: application/json' \
              --data @"$SLACK_PAYLOAD_FILE" \
              "$SLACK_WEBHOOK_URL")
            
            if [ $? -eq 0 ]; then
              echo "âœ… Successfully sent Slack notification via webhook"
            else
              echo "âŒ Failed to send Slack notification via webhook"
              echo "Response: $WEBHOOK_RESPONSE"
            fi
            
            rm -f "$SLACK_PAYLOAD_FILE"
            echo ""
            echo "=========================================="
            echo "âœ… Slack notification step completed"
            echo "=========================================="
          else
            echo ""
            echo "=========================================="
            echo "âš ï¸ Slack Notification Skipped"
            echo "=========================================="
            echo "SLACK_BOT_TOKEN and SLACK_USER_EMAIL (or SLACK_WEBHOOK_URL) not set"
            echo ""
            echo "To enable Slack DM notifications, set the following GitHub Secrets:"
            echo "  - SLACK_BOT_TOKEN: Your Slack Bot Token (xoxb-...)"
            echo "  - SLACK_USER_EMAIL: Your Slack email address"
            echo ""
            echo "Or use webhook:"
            echo "  - SLACK_WEBHOOK_URL: Your Slack Incoming Webhook URL"
            echo ""
            echo "=========================================="
          fi

      # Create a self-healing PR only when this workflow was not triggered by a pull-request.
      - name: Automatically create a pull request for fixing failed tests (if any)
        if: ${{ github.event_name != 'pull_request' }}
        continue-on-error: true
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Fix failing Playwright tests"
          title: "[Fixed] Playwright tests"
          body: |
            This PR was automatically created to fix failing Playwright tests.

            ## Test Results
            Check the workflow run for detailed test results.

            ## Changes
            This PR includes fixes for the failing tests detected in the last run.
          branch: fix-playwright-tests-for-${{ github.ref_name }}
          base: ${{ github.ref_name }}
          delete-branch: true
          # Don't fail if branch already exists
          branch-suffix: timestamp
